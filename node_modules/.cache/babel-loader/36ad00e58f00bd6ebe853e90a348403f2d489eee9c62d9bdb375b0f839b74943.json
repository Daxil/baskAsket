{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar leap = _interopRequireWildcard(require(\"./leap\"));\nvar meta = _interopRequireWildcard(require(\"./meta\"));\nvar util = _interopRequireWildcard(require(\"./util\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction Emitter(contextId) {\n  _assert[\"default\"].ok(this instanceof Emitter);\n  util.getTypes().assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n  this.insertedLocs = new Set();\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = this.loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n// We use 'Number.MAX_VALUE' to mark uninitialized location. We can safely do\n// so because no code can realistically have about 1.8e+308 locations before\n// hitting memory limit of the machine it's running on. For comparison, the\n// estimated number of atoms in the observable universe is around 1e+80.\nvar PENDING_LOCATION = Number.MAX_VALUE;\nEp.loc = function () {\n  var l = util.getTypes().numericLiteral(PENDING_LOCATION);\n  this.insertedLocs.add(l);\n  return l;\n};\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n};\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  var index = this.listing.length;\n  if (loc.value === PENDING_LOCATION) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert[\"default\"].strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\nEp.emit = function (node) {\n  var t = util.getTypes();\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function (lhs, rhs) {\n  var t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function (name, computed) {\n  var t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n  this.jump(this.finalLoc);\n};\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\nEp.clearPendingException = function (tryLoc, assignee) {\n  var t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  var negatedTest;\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\nEp.getContextFunction = function (id) {\n  var t = util.getTypes();\n  return t.functionExpression(id || null /*Anonymous*/, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false,\n  // Not a generator anymore!\n  false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function () {\n  var self = this;\n  var t = util.getTypes();\n  var cases = [];\n  var current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  var alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [\n    // Intentionally fall through to the \"end\" case...\n  ]),\n  // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [\n  // This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n  var t = util.getTypes();\n  var lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n    _assert[\"default\"].ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n    lastLocValue = thisLocValue;\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n    var locs = [tryEntry.firstLoc,\n    // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n    return t.arrayExpression(locs.map(function (loc) {\n      return loc && t.clone(loc);\n    }));\n  }));\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var node = path.node;\n  var self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\nEp.explodeStatement = function (path, labelId) {\n  var t = util.getTypes();\n  var stmt = path.node;\n  var self = this;\n  var before, after, head;\n  t.assertStatement(stmt);\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n    case \"LabeledStatement\":\n      after = this.loc();\n\n      // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n    case \"DoWhileStatement\":\n      var first = this.loc();\n      var test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n    case \"ForStatement\":\n      head = this.loc();\n      var update = this.loc();\n      after = this.loc();\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n      self.mark(head);\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {\n        // No test means continue unconditionally.\n      }\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n      self.jump(head);\n      self.mark(after);\n      break;\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      var defaultLoc = this.loc();\n      var condition = defaultLoc;\n      var caseLocs = [];\n\n      // If there are no cases, .cases might be undefined.\n      var cases = stmt.cases || [];\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n      if (defaultLoc.value === PENDING_LOCATION) {\n        self.mark(defaultLoc);\n        _assert[\"default\"].strictEqual(after.value, defaultLoc.value);\n      }\n      break;\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n      self.mark(after);\n      break;\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n    case \"TryStatement\":\n      after = this.loc();\n      var handler = stmt.handler;\n      var catchLoc = handler && this.loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      var finallyLoc = stmt.finalizer && this.loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: function getSafeParam() {\n              return t.cloneDeep(safeParam);\n            },\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n    case \"ClassDeclaration\":\n      self.emit(self.explodeClass(path));\n      break;\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert[\"default\"].ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n  _assert[\"default\"].notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n  var t = util.getTypes();\n  var abruptArgs = [t.stringLiteral(record.type)];\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\nfunction isValidCompletion(record) {\n  var type = record.type;\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n  return false;\n}\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function (loc) {\n  var t = util.getTypes();\n  if (loc) {\n    t.assertLiteral(loc);\n    if (loc.value === PENDING_LOCATION) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert[\"default\"].strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\n// In order to save the rest of explodeExpression from a combinatorial\n// trainwreck of special cases, explodeViaTempVar is responsible for\n// deciding when a subexpression needs to be \"exploded,\" which is my\n// very technical term for emitting the subexpression as an assignment\n// to a temporary variable and the substituting the temporary variable\n// for the original subexpression. Think of exploded view diagrams, not\n// Michael Bay movies. The point of exploding subexpressions is to\n// control the precise order in which the generated code realizes the\n// side effects of those subexpressions.\nEp.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {\n  _assert[\"default\"].ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n  var t = util.getTypes();\n  var result = this.explodeExpression(childPath, ignoreChildResult);\n  if (ignoreChildResult) {\n    // Side effects already emitted above.\n  } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n    // If tempVar was provided, then the result will always be assigned\n    // to it, even if the result does not otherwise need to be assigned\n    // to a temporary variable.  When no tempVar is provided, we have\n    // the flexibility to decide whether a temporary variable is really\n    // necessary.  Unfortunately, in general, a temporary variable is\n    // required whenever any child contains a yield expression, since it\n    // is difficult to prove (at all, let alone efficiently) whether\n    // this result would evaluate to the same value before and after the\n    // yield (see #206).  One narrow case where we can prove it doesn't\n    // matter (and thus we do not need a temporary variable) is when the\n    // result in question is a Literal value.\n    result = this.emitAssign(tempVar || this.makeTempVar(), result);\n  }\n  return result;\n};\nEp.explodeExpression = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n  var self = this;\n  var result; // Used optionally by several cases below.\n  var after;\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    }\n    return expr;\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? self.explodeViaTempVar(null, path.get(\"property\"), hasLeapingChildren) : expr.property, expr.computed));\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n      var newCallee;\n      var newArgs;\n      var hasLeapingArgs = argsPath.some(function (argPath) {\n        return meta.containsLeap(argPath.node);\n      });\n      var injectFirstArg = null;\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n\n          var newObject = self.explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"), hasLeapingChildren);\n          var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(\"property\"), hasLeapingChildren) : calleePath.node.property;\n          injectFirstArg = newObject;\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n      if (hasLeapingArgs) {\n        newArgs = argsPath.map(function (argPath) {\n          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n        });\n        if (injectFirstArg) newArgs.unshift(injectFirstArg);\n        newArgs = newArgs.map(function (arg) {\n          return t.cloneDeep(arg);\n        });\n      } else {\n        newArgs = path.node.arguments;\n      }\n      return finish(t.callExpression(newCallee, newArgs));\n    case \"NewExpression\":\n      return finish(t.newExpression(self.explodeViaTempVar(null, path.get(\"callee\"), hasLeapingChildren), path.get(\"arguments\").map(function (argPath) {\n        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n      })));\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(\"value\"), hasLeapingChildren), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        if (!elemPath.node) {\n          return null;\n        }\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get(\"argument\"), hasLeapingChildren));\n        } else {\n          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);\n        }\n      })));\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n    case \"LogicalExpression\":\n      after = this.loc();\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n      var left = self.explodeViaTempVar(result, path.get(\"left\"), hasLeapingChildren);\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert[\"default\"].strictEqual(expr.operator, \"||\");\n        self.jumpIf(left, after);\n      }\n      self.explodeViaTempVar(result, path.get(\"right\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n    case \"ConditionalExpression\":\n      var elseLoc = this.loc();\n      after = this.loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n      self.explodeViaTempVar(result, path.get(\"consequent\"), hasLeapingChildren, ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeViaTempVar(result, path.get(\"alternate\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get(\"left\"), hasLeapingChildren), self.explodeViaTempVar(null, path.get(\"right\"), hasLeapingChildren)));\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n      var lhs = self.explodeExpression(path.get(\"left\"));\n      var temp = self.emitAssign(self.makeTempVar(), lhs);\n\n      // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n    case \"YieldExpression\":\n      after = this.loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n        var _ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after]));\n        _ret.loc = expr.loc;\n        self.emit(_ret);\n        self.mark(after);\n        return _result;\n      }\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      var ret = t.returnStatement(t.cloneDeep(arg) || null);\n      // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n    case \"ClassExpression\":\n      return finish(self.explodeClass(path));\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};\nEp.explodeClass = function (path) {\n  var explodingChildren = [];\n  if (path.node.superClass) {\n    explodingChildren.push(path.get(\"superClass\"));\n  }\n  path.get(\"body.body\").forEach(function (member) {\n    if (member.node.computed) {\n      explodingChildren.push(member.get(\"key\"));\n    }\n  });\n  var hasLeapingChildren = explodingChildren.some(function (child) {\n    return meta.containsLeap(child);\n  });\n  for (var i = 0; i < explodingChildren.length; i++) {\n    var child = explodingChildren[i];\n    var isLast = i === explodingChildren.length - 1;\n    if (isLast) {\n      child.replaceWith(this.explodeExpression(child));\n    } else {\n      child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));\n    }\n  }\n  return path.node;\n};","map":{"version":3,"names":["_interopRequireDefault","require","_assert","leap","_interopRequireWildcard","meta","util","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","hasOwn","Emitter","contextId","ok","getTypes","assertIdentifier","nextTempId","listing","marked","insertedLocs","Set","finalLoc","loc","tryEntries","leapManager","LeapManager","Ep","exports","PENDING_LOCATION","Number","MAX_VALUE","l","numericLiteral","add","getInsertedLocs","getContextId","clone","mark","assertLiteral","index","length","value","strictEqual","emit","node","t","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","cloneDeep","contextProperty","name","computed","memberExpression","stringLiteral","identifier","stop","rval","setReturnValue","jump","valuePath","assertExpression","explodeExpression","clearPendingException","tryLoc","assignee","catchCall","callExpression","toLoc","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeTempVar","getContextFunction","id","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ce","catchEntry","fe","finallyEntry","locs","afterLoc","explode","path","ignoreResult","assertNode","isDeclaration","getDeclError","isStatement","explodeStatement","type","Error","JSON","stringify","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","assertSwitchCase","conditionalExpression","binaryExpression","discriminant","replaceWithOrRemove","SwitchEntry","casePath","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","bodyPath","safeParam","traverse","catchParamVisitor","getSafeParam","catchParamName","throwStatement","explodeClass","Identifier","state","isReference","Scope","scope","hasOwnBinding","skip","record","isValidCompletion","notStrictEqual","abruptArgs","isLiteral","explodeViaTempVar","tempVar","childPath","hasLeapingChildren","ignoreChildResult","result","expr","finish","onlyChildren","property","calleePath","argsPath","newCallee","newArgs","hasLeapingArgs","some","argPath","injectFirstArg","isMemberExpression","newObject","newProperty","sequenceExpression","unshift","arg","arguments","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","isSpreadElement","spreadElement","lastIndex","expressions","exprPath","prefix","temp","updateExpression","delegate","_result","_ret","ret","explodingChildren","superClass","member","child","isLast","replaceWith"],"sources":["C:/all prog/BasketCourts/node_modules/regenerator-transform/lib/emit.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar leap = _interopRequireWildcard(require(\"./leap\"));\nvar meta = _interopRequireWildcard(require(\"./meta\"));\nvar util = _interopRequireWildcard(require(\"./util\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction Emitter(contextId) {\n  _assert[\"default\"].ok(this instanceof Emitter);\n  util.getTypes().assertIdentifier(contextId);\n\n  // Used to generate unique temporary names.\n  this.nextTempId = 0;\n\n  // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n  this.contextId = contextId;\n\n  // An append-only list of Statements that grows each time this.emit is\n  // called.\n  this.listing = [];\n\n  // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n  this.marked = [true];\n  this.insertedLocs = new Set();\n\n  // The last location will be marked when this.getDispatchLoop is\n  // called.\n  this.finalLoc = this.loc();\n\n  // A list of all leap.TryEntry statements emitted.\n  this.tryEntries = [];\n\n  // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n  this.leapManager = new leap.LeapManager(this);\n}\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter;\n\n// Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n// We use 'Number.MAX_VALUE' to mark uninitialized location. We can safely do\n// so because no code can realistically have about 1.8e+308 locations before\n// hitting memory limit of the machine it's running on. For comparison, the\n// estimated number of atoms in the observable universe is around 1e+80.\nvar PENDING_LOCATION = Number.MAX_VALUE;\nEp.loc = function () {\n  var l = util.getTypes().numericLiteral(PENDING_LOCATION);\n  this.insertedLocs.add(l);\n  return l;\n};\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n};\n\n// Sets the exact value of the given location to the offset of the next\n// Statement emitted.\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  var index = this.listing.length;\n  if (loc.value === PENDING_LOCATION) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert[\"default\"].strictEqual(loc.value, index);\n  }\n  this.marked[index] = true;\n  return loc;\n};\nEp.emit = function (node) {\n  var t = util.getTypes();\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n  t.assertStatement(node);\n  this.listing.push(node);\n};\n\n// Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n};\n\n// Shorthand for an assignment statement.\nEp.assign = function (lhs, rhs) {\n  var t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n};\n\n// Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\nEp.contextProperty = function (name, computed) {\n  var t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n};\n\n// Shorthand for setting context.rval and jumping to `context.stop()`.\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n  this.jump(this.finalLoc);\n};\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\nEp.clearPendingException = function (tryLoc, assignee) {\n  var t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n};\n\n// Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n};\n\n// Conditional jump.\nEp.jumpIf = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Conditional jump, with the condition negated.\nEp.jumpIfNot = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  var negatedTest;\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n};\n\n// Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\nEp.getContextFunction = function (id) {\n  var t = util.getTypes();\n  return t.functionExpression(id || null /*Anonymous*/, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false,\n  // Not a generator anymore!\n  false // Nor an expression.\n  );\n};\n\n// Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\nEp.getDispatchLoop = function () {\n  var self = this;\n  var t = util.getTypes();\n  var cases = [];\n  var current;\n\n  // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n  var alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  });\n\n  // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [\n    // Intentionally fall through to the \"end\" case...\n  ]),\n  // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [\n  // This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n  var t = util.getTypes();\n  var lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n    _assert[\"default\"].ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n    lastLocValue = thisLocValue;\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n    var locs = [tryEntry.firstLoc,\n    // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n    return t.arrayExpression(locs.map(function (loc) {\n      return loc && t.clone(loc);\n    }));\n  }));\n};\n\n// All side effects must be realized in order.\n\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n\n// No destructive modification of AST nodes.\n\nEp.explode = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var node = path.node;\n  var self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\nEp.explodeStatement = function (path, labelId) {\n  var t = util.getTypes();\n  var stmt = path.node;\n  var self = this;\n  var before, after, head;\n  t.assertStatement(stmt);\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  }\n\n  // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n    case \"LabeledStatement\":\n      after = this.loc();\n\n      // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n    case \"DoWhileStatement\":\n      var first = this.loc();\n      var test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n    case \"ForStatement\":\n      head = this.loc();\n      var update = this.loc();\n      after = this.loc();\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n      self.mark(head);\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {\n        // No test means continue unconditionally.\n      }\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n      self.jump(head);\n      self.mark(after);\n      break;\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      var defaultLoc = this.loc();\n      var condition = defaultLoc;\n      var caseLocs = [];\n\n      // If there are no cases, .cases might be undefined.\n      var cases = stmt.cases || [];\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n      if (defaultLoc.value === PENDING_LOCATION) {\n        self.mark(defaultLoc);\n        _assert[\"default\"].strictEqual(after.value, defaultLoc.value);\n      }\n      break;\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n      self.mark(after);\n      break;\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n    case \"TryStatement\":\n      after = this.loc();\n      var handler = stmt.handler;\n      var catchLoc = handler && this.loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      var finallyLoc = stmt.finalizer && this.loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: function getSafeParam() {\n              return t.cloneDeep(safeParam);\n            },\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n    case \"ClassDeclaration\":\n      self.emit(self.explodeClass(path));\n      break;\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert[\"default\"].ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n  _assert[\"default\"].notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n  var t = util.getTypes();\n  var abruptArgs = [t.stringLiteral(record.type)];\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\nfunction isValidCompletion(record) {\n  var type = record.type;\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n  return false;\n}\n\n// Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n};\n\n// The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\nEp.updateContextPrevLoc = function (loc) {\n  var t = util.getTypes();\n  if (loc) {\n    t.assertLiteral(loc);\n    if (loc.value === PENDING_LOCATION) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert[\"default\"].strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  }\n\n  // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n};\n\n// In order to save the rest of explodeExpression from a combinatorial\n// trainwreck of special cases, explodeViaTempVar is responsible for\n// deciding when a subexpression needs to be \"exploded,\" which is my\n// very technical term for emitting the subexpression as an assignment\n// to a temporary variable and the substituting the temporary variable\n// for the original subexpression. Think of exploded view diagrams, not\n// Michael Bay movies. The point of exploding subexpressions is to\n// control the precise order in which the generated code realizes the\n// side effects of those subexpressions.\nEp.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {\n  _assert[\"default\"].ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n  var t = util.getTypes();\n  var result = this.explodeExpression(childPath, ignoreChildResult);\n  if (ignoreChildResult) {\n    // Side effects already emitted above.\n  } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n    // If tempVar was provided, then the result will always be assigned\n    // to it, even if the result does not otherwise need to be assigned\n    // to a temporary variable.  When no tempVar is provided, we have\n    // the flexibility to decide whether a temporary variable is really\n    // necessary.  Unfortunately, in general, a temporary variable is\n    // required whenever any child contains a yield expression, since it\n    // is difficult to prove (at all, let alone efficiently) whether\n    // this result would evaluate to the same value before and after the\n    // yield (see #206).  One narrow case where we can prove it doesn't\n    // matter (and thus we do not need a temporary variable) is when the\n    // result in question is a Literal value.\n    result = this.emitAssign(tempVar || this.makeTempVar(), result);\n  }\n  return result;\n};\nEp.explodeExpression = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var expr = path.node;\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n  var self = this;\n  var result; // Used optionally by several cases below.\n  var after;\n  function finish(expr) {\n    t.assertExpression(expr);\n    if (ignoreResult) {\n      self.emit(expr);\n    }\n    return expr;\n  }\n\n  // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  }\n\n  // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);\n\n  // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? self.explodeViaTempVar(null, path.get(\"property\"), hasLeapingChildren) : expr.property, expr.computed));\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n      var newCallee;\n      var newArgs;\n      var hasLeapingArgs = argsPath.some(function (argPath) {\n        return meta.containsLeap(argPath.node);\n      });\n      var injectFirstArg = null;\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n\n          var newObject = self.explodeViaTempVar(\n          // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"), hasLeapingChildren);\n          var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(\"property\"), hasLeapingChildren) : calleePath.node.property;\n          injectFirstArg = newObject;\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n      if (hasLeapingArgs) {\n        newArgs = argsPath.map(function (argPath) {\n          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n        });\n        if (injectFirstArg) newArgs.unshift(injectFirstArg);\n        newArgs = newArgs.map(function (arg) {\n          return t.cloneDeep(arg);\n        });\n      } else {\n        newArgs = path.node.arguments;\n      }\n      return finish(t.callExpression(newCallee, newArgs));\n    case \"NewExpression\":\n      return finish(t.newExpression(self.explodeViaTempVar(null, path.get(\"callee\"), hasLeapingChildren), path.get(\"arguments\").map(function (argPath) {\n        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n      })));\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(\"value\"), hasLeapingChildren), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        if (!elemPath.node) {\n          return null;\n        }\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get(\"argument\"), hasLeapingChildren));\n        } else {\n          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);\n        }\n      })));\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n    case \"LogicalExpression\":\n      after = this.loc();\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n      var left = self.explodeViaTempVar(result, path.get(\"left\"), hasLeapingChildren);\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert[\"default\"].strictEqual(expr.operator, \"||\");\n        self.jumpIf(left, after);\n      }\n      self.explodeViaTempVar(result, path.get(\"right\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n    case \"ConditionalExpression\":\n      var elseLoc = this.loc();\n      after = this.loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n      self.explodeViaTempVar(result, path.get(\"consequent\"), hasLeapingChildren, ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeViaTempVar(result, path.get(\"alternate\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator,\n      // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get(\"left\"), hasLeapingChildren), self.explodeViaTempVar(null, path.get(\"right\"), hasLeapingChildren)));\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n      var lhs = self.explodeExpression(path.get(\"left\"));\n      var temp = self.emitAssign(self.makeTempVar(), lhs);\n\n      // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n    case \"YieldExpression\":\n      after = this.loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n        var _ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after]));\n        _ret.loc = expr.loc;\n        self.emit(_ret);\n        self.mark(after);\n        return _result;\n      }\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      var ret = t.returnStatement(t.cloneDeep(arg) || null);\n      // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n    case \"ClassExpression\":\n      return finish(self.explodeClass(path));\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};\nEp.explodeClass = function (path) {\n  var explodingChildren = [];\n  if (path.node.superClass) {\n    explodingChildren.push(path.get(\"superClass\"));\n  }\n  path.get(\"body.body\").forEach(function (member) {\n    if (member.node.computed) {\n      explodingChildren.push(member.get(\"key\"));\n    }\n  });\n  var hasLeapingChildren = explodingChildren.some(function (child) {\n    return meta.containsLeap(child);\n  });\n  for (var i = 0; i < explodingChildren.length; i++) {\n    var child = explodingChildren[i];\n    var isLast = i === explodingChildren.length - 1;\n    if (isLast) {\n      child.replaceWith(this.explodeExpression(child));\n    } else {\n      child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));\n    }\n  }\n  return path.node;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}